---
title: "Clasificación Imágenes - Correlación"
author: "crsd"
date: "05 de marzo de 2019"
output: 
      html_document:
            code_folding: hide
            toc: true
            toc_depth: 3
            number_sections: false
            theme: united
            highlight: tango
            css: air.css
            keep_md: true
---

```{r setup, cache=FALSE}
timeProc <- proc.time()
suppressMessages(library(EBImage))
suppressMessages(library(rgl))
suppressMessages(library(caret))
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(kknn))
suppressMessages(library(randomForest))
suppressMessages(library(ggplot2))

```

# Resumen

MNIST ("Instituto Nacional Modificado de Estándares y Tecnología") es el conjunto de datos de facto de "visión mundial" de la visión de computadora. Desde su lanzamiento en 1999, este clásico conjunto de datos de imágenes manuscritas ha servido como base para los algoritmos de clasificación de referencia. A medida que surgen nuevas técnicas de aprendizaje automático, MNIST sigue siendo un recurso confiable para investigadores y estudiantes por igual.



El conjunto de datos mixto de Instituto Nacional de estándares y tecnología (MNIST) es una colección de 70.000 pequeñas imágenes de dígitos escritos a mano. Los datos fue creados para actuar como un referente para los algoritmos de reconocimiento de imagen. Aunque MNIST las imágenes son pequeñas (28 x 28 pixeles) y sólo hay 10 dígitos posibles (cero a nueve) a reconocer y hay 42.0000 imágenes de formación para la creación de un modelo de reconocimiento de imagen (con 28.000 imágenes tendidas a probar la exactitud de un modelo), la experiencia ha demostrado que reconocer las imágenes MNIST es un problema difícil.

Para lidiar con este problema vamos a extraer características de cada imagen y disminuir el tamaño de cada muestra. Con esto probaremos el desempeño de clasificadores.

# Extraccion de características

Al revisar los datos tenemos un archivo con 42000 imágenes con 785 variables (28x28 píxeles) cada una, esto resulta en 33 millones de datos aproximadamente. Donde la primera columna es el número en la imagen y las 784 restantes corresponden a la imagen del número, como se puede er en la imagen siguiente (primeros 250 dígitos).


```{r Load data, cache=TRUE, comment=""}
# lee archivo con datos de entrenamiento (imagenes de 28x28)
train <- read.csv("train.csv")
train$label <- factor(train$label)
# train[,c(2:785)] <- round(train[,c(2:785)], digits = 0)

dim(train)
str(train[,1:10])

l <- 1
for (i in 1:10) {
      for (k in 1:25) {
            if(k==1){
                  b <- matrix(unlist(train[l,-1])/255, ncol = 28, nrow = 28)
            }
            if(k>1){
                  a <- matrix(unlist(train[l,-1])/255, ncol = 28, nrow = 28)
                  b <- rbind(b,a) 
            }
            l <- l+1
      }
      if(i==1){
            c <- b
            remove(b)
      }
      if(i>1){
            c <- cbind(c,b)
            remove(b)
      }
}

display(colormap(c, palette = topo.colors(256)), method = "raster")
title("Primeros 250 dígitos escritos a mano")
```

Para disminuir la gran cantidad de datos es necesario realizar algunas transformaciones y extraer información resumida de la imagen. En este caso consideraremos los siguientes pasos:

- **Reagrupar píxeles**: Se ordenarán los píxeles en matrices de 28 x 28.
- **Extraer referencia**: Se considera utilizar como referecia al promedio de imagenes de cada clase.
      
      > $I_{ref}^c(i,j) = \frac{1}{n} \sum_{k=1}^{n} Im^c(i,j,k)$
      
- **Correlación**: Se calcula la correlación de "Pearson" de cada imagen por cada referencia de clase
      
      > $C^c =  \frac{\sum_{k=1}^{n} (Im(i,j,k) - \overline{Im(i,j,k)})(I_{ref}^c(i,j) - \overline{I_{ref}^c(i,j)})}{\sqrt{\sum_{k=1}^{n} (Im(i,j,k) - \overline{Im(i,j,k)})^2}\sqrt{\sum_{k=1}^{n} (I_{ref}^c(i,j) - \overline{I_{ref}^c(i,j)})^2}}$

El superindice $^c$ representa una imagen o medida asociada a la clase $c$, y el $\overline{x}$ representa el promedio de $x$.

Con esto podemos reducir el número de dimensiones de 785 a 11, que representa alrededor de un 1.4% de los datos originales.

A continuación podemos observar la estructura de cada característica para cada clase, observando distribuciones ligeramente diferentes en cada caso, esto nos servirá a la hora de clasificar cada clase.

```{r DistMin, cache=TRUE, comment="", eval=TRUE}
# Creacion de conjunto de entrenamiento y pruebas
set.seed(28916022)
Index1 <- createDataPartition(y = train$label, p = 0.7, list = FALSE)
t <- train[Index1,]

# promedio de las imagenes
t0 <- t[1:10,]
for (i in 0:9) {
      t0[i+1,1] <- i
      t0[i+1,-1] <- as.numeric(colMeans(t[t$label==i,-1]))
      t0[i+1,-1] <- t0[i+1,-1]*255/max(t0[i+1,-1])
}

t1 <- data.frame()
for (i in 1:dim(train)[1]) {
      t1[i,1] <- train[i,1]
      a <- data.frame(as.numeric(train[i,-1]), stringsAsFactors = FALSE)
      # correlacion
      for (j in 0:9) {
            # t1[i,j+2] <- dist(rbind(t0[j+1,-1], train[i,-1]), method = "euclidean")
            t1[i,j+2] <- cor(t(t0[j+1,-1]), a)
      }
}
colnames(t1) <- c("label", "corr0", "corr1", "corr2", "corr3", "corr4", "corr5",
                  "corr6", "corr7", "corr8", "corr9")
saveRDS(t1,"caract_3_data.rds")
saveRDS(t0,"caract_3_means.rds")
```


```{r MuestraDatos, cache=TRUE, comment=""}
t1 <- readRDS("caract_3_data.rds")
t1$label <- factor(t1$label)
str(t1)

t2 <- gather(t1, key = caracteristica, value = valor, corr0:corr9, factor_key = TRUE)

ggplot(data=t2, aes(caracteristica, valor,color=label)) +
      geom_boxplot() + facet_wrap(label~., ncol = 3) + ggtitle("Correlación por cada dígito") +
      theme(axis.text.x = element_text(angle = 90, hjust = 1)) 
```


# Modelo

Antes demodelar debemos dividir los datos reducidos en conjunto de entrenamiento y prueba, con 70% y 30% del total respectivamente.

Con el conjunto de entrenamiento modelaremos 2 clasificadores:

- **LogitBoost**, Este es un algoritmo basado en arboldes de decisión. Para mayor información revisar:

      https://www.rdocumentation.org/packages/caTools/versions/1.17.1/topics/LogitBoost

- **KNN**, Este algoritmo realiza la clasificación de k-nearest neighbor de un conjunto de prueba utilizando un conjunto de entrenamiento. Para cada fila del conjunto de pruebas, se encuentran los k vectores de conjunto de entrenamiento más cercanos (según la distancia de Minkowski), y la clasificación se realiza a través del máximo de densidades del núcleo sumadas. Además se pueden predecir incluso variables ordinales y continuas. Para mayor información revisar:

      https://www.rdocumentation.org/packages/kknn/versions/1.3.1/topics/kknn


En ambos casos consideraremos para entrenamiento validación cruzada con 5 folds.

El resultado del entrenamiento se muestra a continuación.

```{r Clasificador, cache=TRUE, comment="", eval=TRUE}
# crea conjunto entrenamiento 70%-30%
# El indice Index1 se creó más arriba
TEST <- t1[-Index1,]
TRAIN <- t1[Index1,]
# Genera modelos
trC=trainControl(method="cv", number=5)
m="Accuracy"
# KNN
set.seed(2891)
KNNGrid <-  expand.grid(kmax = 9, distance = 1, kernel = "epanechnikov")
fitKNN <- train(label~., data=TRAIN, method="kknn", metric=m,
                trControl=trC, tuneGrid = KNNGrid)

PredKNNtrain<-predict(fitKNN, newdata=TRAIN)
PredKNNtest<-predict(fitKNN, newdata=TEST)
CM_Train_KNN <- confusionMatrix(PredKNNtrain, TRAIN$label)
CM_Test_KNN <- confusionMatrix(PredKNNtest, TEST$label)
saveRDS(fitKNN, "fitKNN3.rds")
saveRDS(CM_Train_KNN, "CM_Train_KNN3.rds")
saveRDS(CM_Test_KNN, "CM_Test_KNN3.rds")
# LogitBoost
fitLGB <- train(label~., data=TRAIN, method="LogitBoost", metric=m, trControl=trC)
PredLGBtrain<-predict(fitLGB, newdata=TRAIN)
PredLGBtest<-predict(fitLGB, newdata=TEST)
CM_Train_LGB <- confusionMatrix(PredLGBtrain, TRAIN$label)
CM_Test_LGB <- confusionMatrix(PredLGBtest, TEST$label)
saveRDS(fitLGB, "fitLGB3.rds")
saveRDS(CM_Train_LGB, "CM_Train_LGB3.rds")
saveRDS(CM_Test_LGB, "CM_Test_LGB3.rds")
```


```{r modelos, cache=TRUE, comment=""}
fitKNN <- readRDS("fitKNN3.rds")
fitLGB <- readRDS("fitLGB3.rds")

fitKNN
fitLGB
```


# Pruebas

Ambos clasificadores presentan un buen desempeño para clasificar digitos. Ahora se muestra el resultado de las pruebas con el 30% de datos asignado al conjunto de pruebas.

```{r pruebas, cache=TRUE, comment=""}
CM_Test_KNN <- readRDS("CM_Test_KNN3.rds")
CM_Test_LGB <- readRDS("CM_Test_LGB3.rds")

CM_Test_KNN
CM_Test_LGB
```

El resultado es similar al entrenamiento, por lo que ambos clasificadores funcionan bien y no están sobre entrenados.

---

# Conclusiones

Ambos clasificadores presentan un buen desempeño superior al 87%.

La reduccion de dimensiones permitió reducir el tiempo de ejecución en mi computador de manera considerable. Esto es importante, ya que si consideramos un problema similar con imagenes más grandes la cantidad de dimensiones seguiría igual, ya que depende de las clases.

Este es un buen desempeño considerando la información pérdida. Este parece ser un buen enfoque entre rendimiento vs complejidad. Aunque es posible de mejorar.

---

# Referencia

Para revisar el código de este trabajo ir a:

https://github.com/desareca/Procesamiento-Imagenes-R

---

# Tiempo de ejecución

El tiempo de ejecución se detalla a continuación:

```{r time, cache=TRUE, comment=""}
FinalTime <- proc.time() - timeProc
FinalTime
```

---

# Información de sesión

```{r session, cache=FALSE, comment=""}
sessionInfo()
```








